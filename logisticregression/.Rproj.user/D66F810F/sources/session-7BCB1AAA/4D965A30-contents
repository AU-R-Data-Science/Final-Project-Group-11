# 1) Create a function that computes the theoretical wavelet variance of
#a white noise process (i.e. sigma2/tau). Therefore the dimension of the
#parameter vector is actually p = 1. The skeleton of this function with
#relative arguments is given below (but you can disregard it and define
                                   #it in another way if you prefer).
wn_theo <- function(sigma2, J) {
  #sigma2 is sigma^2
  j <- c(1:J)
  tau_j <- 2^j
  return(sigma2/J)
}


# 2) Using the function defined in Question 1, create the loss function for
#the GMWM to estimate the parameter of the white noise process. For the matrix
#Omega use the identity (i.e. ones on the diagonal and zeros elsewhere).
#The skeleton of this function with relative arguments is given below
#(but you can disregard it and define it in another way if you prefer).
wn_loss <- function(sigma2, nu_hat, J) {

  omega <- diag(J)
  t(nu_hat - wn_theo(sigma2, J))%*%omega%*%(nu_hat - wn_theo(sigma2, J))

}

# 3) Create a function that estimates the parameter of the white noise process
#(sigma2) by minimizing the loss function defined in Question 2. Aside from the
#data (time series) as an argument, provide the user with the option to choose
#whether they want to use a robust estimator or not. The skeleton of this
#function with relative arguments is given below and all you need to do is fill
#in the three dots (i.e. "...") with the required code. However, you can disregard
#this skeleton and define this function in another way if you prefer.
library(wv)
my_gmwm <- function(x, sigma2, robust) {
  T <- length(x)
  J <- floor(log(T,base = 2))-1

  if(robust) {

    nu_hat <- wvar(x, robust = TRUE)$variance

  } else {

    nu_hat <- wvar(x, robust = FALSE)$variance

  }

  suppressWarnings(sigma2_hat <- optim(0, wn_loss)$par)

  return(sigma2_hat)

}

# 4) Write a code for a simulation study with 100 replications and samples of
#size 1000 coming from a white noise process with parameter sigma2 = 1.
#For each simulated sample (say Xt), you will create a copy (say Zt) and
#modify 10 randomly selected observations from it by replacing them with 10
#observations from an exponential distribution with rate parameter equal to 0.5.
#Then, on both Xt and Zt, you will use the GMWM function from Question 3 to
#estimate the parameter of the white noise using the standard estimator and
#the robust estimator. This procedure delivers four estimations in total for
#each replication which you should save into the appropriate objects.
#The skeleton of this simulation is given below and all you need to do is fill
#in the three dots (i.e. "...") with the required code. However, you can
#disregard this skeleton and program the simulation in another way if you prefer.
library(simts)
B <- 100
n <- 1000
cont <- 10
true_sigma2 <- 1
i=1
sigma2_Xt_std <- sigma2_Xt_rob <- sigma2_Zt_std <- sigma2_Zt_rob <- rep(NA,B)
for(i in 1:B) {

  Xt <- gen_gts(n, WN(sigma2 = 1))
  Zt <- Xt
  Zt[sample(n, cont, replace = FALSE)] = rexp(cont, rate = 0.5)

  sigma2_Xt_rob[i] <- my_gmwm(Xt, sigma2 , robust = TRUE)
  sigma2_Xt_std[i] <- my_gmwm(Xt, sigma2 , robust = FALSE)

  sigma2_Zt_rob[i] <- my_gmwm(Zt, sigma2 , robust = TRUE)
  sigma2_Zt_std[i] <- my_gmwm(Zt, sigma2 , robust = FALSE)

}

# 5) Compute the Median Absolute Error (MAE) of the standard and robust
#estimators in the case of Xt and Zt samples (so four MAEs in total). Also,
#produce boxplots comparing them to the true parameter value sigma2 = 1.
#Using the comment syntax in R, comment on how these estimators behave
#in the different settings.

MAE_Xt_rob <- median(abs(sigma2_Xt_rob-1))
MAE_Xt_std <- median(abs(sigma2_Xt_std-1))

MAE_Zt_rob <- median(abs(sigma2_Zt_rob-1))
MAE_Zt_std <- median(abs(sigma2_Zt_std-1))

data <- data.frame(MAE_Xt_rob,MAE_Xt_std,MAE_Zt_rob,MAE_Zt_std)
boxplot(data)

