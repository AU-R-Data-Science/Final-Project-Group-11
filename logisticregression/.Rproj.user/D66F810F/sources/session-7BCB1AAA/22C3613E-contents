## Mean optimization
mean_obj1 <- function(data, mu) { # objective function for the mean

  sum((data - mu)^2) # L2 norm

}

## Median optimization
mean_obj2 <- function(data, mu) { # objective function for the mean?

  sum(abs(data - mu)) # L1 norm

}

x <- rnorm(100, mean = 4, sd = 1) # generate data with true mean equal to 4


## Optimization function
optim_center <- function(data, f, H = 10000, seed = NA, tol = 10e-6) {

  min_x <- min(data)
  max_x <- max(data)

  f_old <- f(data, max_x) # get a high function value to start the evaluation
  
  if(!is.na(seed)) set.seed(seed)

  for(i in 1:H) {

    guess <- runif(n = 1, min = min_x, max = max_x)

    f_value <- f(data, guess)

    if(f_value < f_old) {

      final_mu <- guess

      if(f_old - f_value <= tol) {

        break

      }

      f_old <- f_value

    }

  }

  #return(final_mu)
  output <- list("mu_hat" = final_mu, "obj_value" = f_value)
  output

}


# What if we have data from an exponential distribution?

x <- rexp(100, rate = 3)

optim_center(data = x, f = mean_obj1)
optim_center(data = x, f = mean_obj2)

# Simulation study
n <- 100
rate <- 3

true_mean <- 1/rate
true_median <- log(2)/rate

B <- 50

l1_mean <- l2_mean <- rep(NA, B)

set.seed(123) # How do we solve the seed problem in the function?

for(b in 1:B) {

  x <- rexp(n, rate = rate)

  l2_mean[b] <- optim_center(data = x, f = mean_obj1)$mu_hat

  l1_mean[b] <- optim_center(data = x, f = mean_obj2)$mu_hat

}

boxplot(l2_mean, l1_mean)
abline(h = true_mean, col = "green")
abline(h = true_median, col = "blue")

## Random Walk
# Control seed
set.seed(1992)

# Starting point
start_pos <- c(100, 100)
final_pos <- c(50, 50)
passo <- rep(0, 2)

# Proximity
close <- 50
dist <- close + 1
# Number of steps
steps <- 10^5

# Direction probability (i.e. all direction are equally likely)
probs <- c(0.25, 0.5, 0.75)

iter <- 0
# Start random walk
#for (i in seq(2, steps+1)){
while(dist > close & iter <= 10^5) {
  # Draw a random number from U(0,1)
  rn = runif(1)
  
  # Go right if rn \in [0,prob[1])
  if (rn < probs[1]) {passo[1] = 1}
  
  # Go left if rn \in [probs[1], probs[2])
  if (rn >= probs[1] && rn < probs[2]) {passo[1] = -1}
  
  # Go forward if rn \in [probs[2], probs[3])
  if (rn >= probs[2] && rn < probs[3]) {passo[2] = 1}
  
  # Go backward if rn \in [probs[3],1]
  if (rn >= probs[3]) {passo[2] = -1}
  
  start_pos <- start_pos + passo
  dist <- sqrt(sum((start_pos - final_pos)^2))
  
  passo <- rep(0, 2)
  iter <- iter + 1
  
}
